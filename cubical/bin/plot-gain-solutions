#!/usr/bin/env python
from __future__ import print_function

from collections import OrderedDict
import pylab
import numpy as np

from cubical.plots import gainsols

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="""Makes plots of leakage solutions""",
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument("-d", "--display", action="store_true", help="Display plots rather than saving them")

    parser.add_argument("-o", "--output-name", type=str, metavar="FILENAME", help="Output filename")

    parser.add_argument("-b", "--plot-bandpass", action="store_true", help="Display bandpass plots too")

    parser.add_argument("-r", "--ref-ant", metavar="ANTENNA", type=str, help="Impose a reference antenna on the leakages")

    parser.add_argument("--diff", action="store_true", help="Make difference plots if possible")

    parser.add_argument("--nrow", type=int, default=7, help="Plot rows")
    parser.add_argument("--ncol", type=int, default=4, help="Plot columns")
    parser.add_argument("--width", type=float, metavar="INCHES", default=4, help="Plot width")
    parser.add_argument("--height", type=float, metavar="INCHES", default=3, help="Plot height")
    parser.add_argument("--dpi", type=int, default=150, help="Plot DPI")
    parser.add_argument("--font-size", type=int, default=6, help="Font size")
    parser.add_argument("--min-freq", type=float, metavar="MHz", default=0, help="Start frequency")
    parser.add_argument("--max-freq", type=float, metavar="MHz", default=0, help="End frequency")
    parser.add_argument("--max-reim", type=float, metavar="VALUE", default=0.05, help="Sets re/im axis limits")

    parser.add_argument("files", nargs="+",
                         help="""One or more CubiCal solution databases or AIPS leakage files""")

    options = leakages.options = parser.parse_args()

    Daips0 = None

    for filename in options.files:
        figtitle = filename
        output_name = options.output_name or filename + ".png"
        differential = False
        refant = None

        # check file type
        line0 = open(filename).readline().strip()
        if line0.startswith("PD TABLE"):
            print("{} seems to be an AIPS PD table printout".format(filename))

            leak, antennas, freq = Daips = leakages.read_aips_leakages(filename)
            ant_index = {a: i for i, a in enumerate(antennas)}

            figtitle = filename
            output_name = options.output_name or filename + ".png"
            differential = False
            refant = None

            if options.ref_ant and options.ref_ant != "auto":
                refant = options.ref_ant
                leakages.apply_ref_ant(leak, options.ref_ant, ant_index)

            if options.diff:
                if Daips0 is None:
                    Daips0 = Daips
                    filename0 = filename
                else:
                    figtitle = "{} minus {}".format(filename, filename0)
                    output_name = options.output_name or filename + ".diff.png"
                    differential = True

                    leak0, antennas0, freq0 = Daips0
                    ant0_index = {a: i for i, a in enumerate(antennas0)}

                    if len(freq) != len(freq0) or (freq != freq0).any():
                        "{}: frequency axis mismatch, can't show difference to {}".format(filename, filename0)
                        continue

                    # look for best reference antenna
                    rms_diff = OrderedDict()
                    if options.ref_ant == "auto":
                        #print("Picking reference antenna for differencing")
                        for refant in set(antennas) & set(antennas0):
                            leakages.apply_ref_ant(leak, refant, ant_index)
                            leakages.apply_ref_ant(leak0, refant, ant0_index)
                            diffleak = leakages.subtract_leakages(leak, antennas, leak0, ant0_index)
                            rms_diff[refant] = diffleak[...,(0,1),(1,0)].std(axis=(1,-1)).mean(axis=1)
                            #print("  ref ant {}: mean rms {}".format(refant,rms_diff[refant]))
                        imin = np.argmin(np.array(rms_diff.values()))
                        refant = rms_diff.keys()[imin]
                        print("Auto-picking reference antenna {}".format(refant))
                        leakages.apply_ref_ant(leak, refant, ant_index)
                        leakages.apply_ref_ant(leak0, refant, ant0_index)

                    diffleak = leakages.subtract_leakages(leak, antennas, leak0, ant0_index)

                    Daips = diffleak, antennas, freq

            if refant:
                figtitle += " (re-referenced to antenna {})".format(refant)


            fig = leakages.plot_leakages_aips(Daips, reim=(-options.max_reim, options.max_reim),
                                       minfreq=options.min_freq*1e+6 or None,
                                       maxfreq=options.max_freq*1e+6 or None,
                                       figsize=(options.width*options.ncol, options.height*options.nrow),
                                       ncol=options.ncol,nrow=options.nrow,
                                       figtitle=figtitle, plot_bandpass=options.plot_bandpass, diff=differential)

            if options.display:
                print("Displaying plot")
#                fig.show()
            else:
                print("Saving plot to {}".format(output_name))
                fig.savefig(output_name, dpi=options.dpi, bbox_inches='tight')

        else:
            print("Trying to read {} as a CubiCal database".format(filename))
            Dcc = leakages.read_cubical_leakages(filename)
            if options.ref_ant:
                figtitle += " (re-referenced to antenna {})".format(refant)
            fig = leakages.plot_leakages_cc(Dcc, reim=(-options.max_reim, options.max_reim),
                                       minfreq=options.min_freq*1e+6 or None,
                                       maxfreq=options.max_freq*1e+6 or None,
                                       figsize=(options.width*options.ncol, options.height*options.nrow),
                                       ncol=options.ncol,nrow=options.nrow,
                                       refant=options.ref_ant,
                                       figtitle=figtitle, plot_bandpass=options.plot_bandpass)

    if options.display:
        pylab.show()