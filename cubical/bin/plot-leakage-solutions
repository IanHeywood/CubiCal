#!/usr/bin/env python
from __future__ import print_function

import numpy as np
from collections import OrderedDict
import matplotlib.patches as mpatches
from pylab import *

def plot_leakages(sols, ncol=4, nrow=14, figsize=(16, 42), reim=False, plot_bandpass=True, diff=False, figtitle=None):
    """
    Makes leakage plots given by sols dict
    """
    fig = figure(figsize=figsize, dpi=options.dpi)
    tight_layout()
    subplots_adjust(left=0.05, bottom=0.05, right=0.95, top=0.95)
    if figtitle:
        fig.suptitle(figtitle, fontsize=options.font_size*2)

    nplot = 0

    for iant, (ant, (time, freq, d00, d01, d10, d11)) in enumerate(sols.items()):
        #    print "shape is {}, grid span is {} {}".format(d00.shape, time[[0,-1]], freq[[0,-1]])
        freq = freq * 1e-9
        fontdict = dict(fontsize=options.font_size)
        fontdict_title = dict(weight='bold', fontsize=options.font_size * 1.2)

        if plot_bandpass:
            if nplot >= nrow*ncol:
                print("Warning: out of plot space. You probably want to add more rows or columns")
                break
            nplot += 1
            ax = subplot(nrow, ncol, nplot)
            title("{} antenna {}".format("Diff bandpass" if diff else "Bandpass",ant), fontdict=fontdict_title)
            if (nplot - 1) / ncol == nrow - 1:
                ax.set_xlabel("Frequency (GHz)", fontdict=fontdict)
            ax.tick_params("x", direction="in")
            if nplot % ncol == 1:
                ax.set_ylabel("Amplitude", fontdict=fontdict)
            ax2 = ax.twinx()
            ax2.set_ylim(-180, 180)
            ax2.set_yticks([])
            for ts in xrange(d00.shape[0]):
                p1 = ax2.plot(freq, np.angle(d00[ts]) * 180 / math.pi, '.c', ms=0.5, label="RR phase" if not ts else None)
                p2 = ax2.plot(freq, np.angle(d11[ts]) * 180 / math.pi, '.y', ms=0.5, label="LL phase" if not ts else None)
                a1 = ax.plot(freq, abs(d00[ts]), '+r', ms=2, label="|RR|" if not ts else None)
                a2 = ax.plot(freq, abs(d11[ts]), '+b', ms=2, label="|LL|" if not ts else None)
            ax.set_ylim(0.99, 1.05)
            if not iant:
                ax.legend(handles=[mpatches.Patch(color=col, label=label) for col, label in
                                   ("r", "|RR|"), ("b", "|LL|"),
                                   ("c", "RR phase"), ("y", "LL phase")
                                   ], loc="upper center", fontsize=options.font_size)
            for axis in ax.xaxis, ax.yaxis:
                for tick in axis.get_major_ticks():
                    tick.label.set_fontsize(options.font_size)
        # legend([a1,a2,p1,p2],["|RR|","|LL|","RR phase"," LL phase"])

        if nplot >= nrow*ncol:
            print("Warning: out of plot space. You probably want to add more rows or columns")
            break
        nplot += 1
        ax = subplot(nrow, ncol, nplot)
        title("{} antenna {}".format("Diff leakages" if diff else "Leakages", ant), fontdict=fontdict_title)
        ax.set_ylim(-0.3, 0.3)
        if (nplot - 1) / ncol == nrow - 1:
            ax.set_xlabel("Frequency (GHz)", fontdict=fontdict)
        for axis in ax.xaxis, ax.yaxis:
            for tick in axis.get_major_ticks():
                tick.label.set_fontsize(options.font_size)
        ax.tick_params("x", direction="in")
        if reim:
            for ts in xrange(d01.shape[0]):
                ax.plot(freq, d01[ts].real, '+r', ms=2, label="Re RL" if not ts else None)
                ax.plot(freq, d01[ts].imag, '+b', ms=2, label="Im RL" if not ts else None)
            for ts in xrange(d10.shape[0]):
                ax.plot(freq, d10[ts].real, '+c', ms=2, label="Re LR" if not ts else None)
                ax.plot(freq, d10[ts].imag, '+y', ms=2, label="Im LR" if not ts else None)
            if isinstance(reim, (list, tuple)):
                ax.set_ylim(*reim)
            if not iant:
                ax.legend(handles=[mpatches.Patch(color=col, label=label) for col, label in
                                   ("r", "Re RL"), ("b", "Im RL"),
                                   ("c", "Re LR"), ("y", "Im LR")
                                   ], loc="upper center", fontsize=options.font_size)
        else:
            ax2 = ax.twinx()
            ax2.set_ylim(-180, 180)
            if nplot % ncol == 0:
                ax2.set_ylabel("Phase (deg)", fontdict=fontdict)
            else:
                ax2.set_yticks([])
            for ts in range(d01.shape[0]):
                p1 = ax2.plot(freq, np.angle(d01[ts]) * 180 / math.pi, '.c', ms=0.5,
                              label="RL phase" if not ts else None)
                p2 = ax2.plot(freq, np.angle(d10[ts]) * 180 / math.pi, '.y', ms=0.5,
                              label="LR phase" if not ts else None)
                a1 = ax.plot(freq, abs(d01[ts]), '+r', ms=2, label="|RL|" if not ts else None)
                a2 = ax.plot(freq, abs(d10[ts]), '+b', ms=2, label="|LR|" if not ts else None)
            if not iant:
                ax.legend(handles=[mpatches.Patch(color=col, label=label) for col, label in
                                   ("r", "|RL|"), ("b", "|LR|"),
                                   ("c", "RL phase"), ("y", "LR phase")
                                   ], loc="upper center", fontsize=options.font_size)
    #     plot(freq,d01[0].real,'.b',ms=.8,label="RL real")
    #     plot(freq,d01[0].imag,'.r',ms=.8,label="RL imag")
    #     plot(freq,d10[0].real,'.g',ms=.8,label="LR real")
    #     plot(freq,d10[0].imag,'.m',ms=.8,label="LR imag")
    # fig.tight_layout()
    print("{} plots generated ({} rows and {} columns)".format(nplot, nrow, ncol))
    return fig
    # you can see this is a masked array, so flagged-out solutions are not plotted


def plot_leakages_cc(D, FS=slice(None), TS=slice(None), ANTS=slice(None), refant=None, ncol=4, nrow=14,
                     figsize=(16, 42), reim=False, plot_bandpass=True, diff=False, figtitle=None):
    """Plots leakages from a CubiCal database"""
    from collections import OrderedDict
    import matplotlib.patches as mpatches

    sols = OrderedDict()
    if type(TS) is int:
        TS = slice(TS, TS + 1)
    # get valid D solutions
    if isinstance(ANTS, (list, tuple)):
        ANTS = [(ant, D.grid[D.ax.ant][ant]) for ant in ANTS]
    else:
        ANTS = enumerate(D.grid[D.ax.ant][ANTS])
    for iant, ant in ANTS:
        # this gets the "raw" solutions for a given slice (antenna, correlation, etc.), and also the grid they're defined on,
        # which could be a subset of the full grid given by the description
        d00, (time, freq) = D.get_slice(ant=iant, corr1=0, corr2=0)
        if d00 is None:
            continue
        d01, (time, freq) = D.get_slice(ant=iant, corr1=0, corr2=1)
        d10, (time, freq) = D.get_slice(ant=iant, corr1=1, corr2=0)
        d11, (time, freq) = D.get_slice(ant=iant, corr1=1, corr2=1)
        d01 = d01 / d00
        d10 = d10 / d11
        sols[ant] = time[TS], freq[FS], d00[TS, FS], d01[TS, FS], d10[TS, FS], d11[TS, FS]

    if refant is not None:
        d01ref = sols[refant][3]
        sols = OrderedDict([(ant, (t, f, d00, d01 - d01ref, d10 + np.conj(d01ref), d11))
                            for ant, (t, f, d00, d01, d10, d11) in sols.items()])

    plot_leakages(sols, ncol=ncol, nrow=nrow, figsize=figsize, reim=reim, plot_bandpass=plot_bandpass, diff=diff, figtitle=figtitle)

def read_cubical_leakages(filename):
    """
    Reads cCubiCal leakage solutions from a CubiCal DB
    """
    import cubical
    from cubical.database import pickled_db
    db = pickled_db.PickledDatabase()
    db._load(filename)
    print("{} contains solutions for {}".format(filename, " ".join(db.names())))
    D = db['D:gain']  # G is a Parameter object
    Derr = db['D:gain.err']  # G is a Parameter object
    print("  ",D.shape, D.axis_labels)  # axis info
    print("  can be interpolated over axes", D.interpolation_axes)
    print("   antennas are", D.grid[D.ax.ant])
    time, freq = D.grid[D.ax.time], D.grid[D.ax.freq]  # grid info
    print("  grid span is ", time[[0, -1]], freq[[0, -1]])
    minfreq, maxfreq = freq[[0, -1]]
    # this is how to check for valid slices
    print("  valid antennas", " ".join([ant for ant in range(len(D.grid[D.ax.ant]))
                                            if D.is_slice_valid(ant=ant, corr1=0, corr2=0)]))

def plot_leakages_aips(Daips, FS=slice(None), ANTS=slice(None), minfreq=None, maxfreq=None,
                       ncol=4, nrow=14, figsize=(16,42), reim=False, plot_bandpass=True, diff=False, figtitle=None):
    """
    Plots AIPS leakage solutions
    """
    Da, all_ants, all_freqs = Daips
    if0 = if1 = None
    if minfreq is not None:
        wh = np.where(all_freqs>=minfreq)[0]
        if0 = wh[0] if len(wh) else None
    if maxfreq is not None:
        wh = np.where(all_freqs>=maxfreq)[0]
        if1 = wh[0] if len(wh) else None
    if if0 is not None or if1 is not None:
        FS = slice(if0 or 0, if1)
    sols = OrderedDict()
    # get valid D solutions
    if isinstance(ANTS, (list, tuple)):
        ANTS = [(ant, all_ants[ant]) for ant in ANTS]
    else:
        ANTS = enumerate(all_ants[ANTS])
    time = np.array([0.])
    freq = all_freqs[FS]
    for iant,ant in ANTS:
        d00 = Da[:, FS, iant, 0, 0]
        d01 = Da[:, FS, iant, 0, 1]
        d10 = Da[:, FS, iant, 1, 0]
        d11 = Da[:, FS, iant, 1, 1]
        sols[ant] = time,freq,d00,d01,d10,d11

    return plot_leakages(sols, ncol=ncol, nrow=nrow, figsize=figsize, reim=reim, plot_bandpass=plot_bandpass,
                         diff=diff, figtitle=figtitle)

def read_aips_leakages(filename):
    """
    Reads AIPS leakage solutions from text file.

    Returns:
        leakage_array [(1,NFREQ,NANT,2,2) complex], antenna_names [(NANT) str], frequencies [(NFREQ) float]
    """
    import re, cmath
    from collections import OrderedDict
    allfreqs = set()
    aips_rel_leak = OrderedDict()
    antenna = antdict = None
    for iline, line in enumerate(open(filename).readlines()):
        match = re.match("\s*Antenna #\s+(\d+)\s+ name: (\w+)", line)
        if match:
            antenna, antname = match.groups()
            # print("Found antenna {} ({})".format(antenna, antname))
            antdict = aips_rel_leak.setdefault(antenna, dict(R=OrderedDict(), L=OrderedDict()))
            continue
        fields = line.strip().split()
        if len(fields) == 7:
            try:
                pol = fields[2]
                freq = float(fields[3]) * 1e+6
                amp = float(fields[5])
                phase = float(fields[6])
            except:
                continue
            if antdict is None:
                print("line {}: leakage entry before active antenna entry".format(iline + 1))
                continue
            antdict[pol][freq] = d = amp * cmath.exp(1j * phase * cmath.pi / 180)
            allfreqs.add(freq)
            # print("  {} {} MHz: {}".format(pol, freq, d))
    # filter out missing antennas
    missing = []
    for antenna, antdict in aips_rel_leak.items():
        if (np.array([antdict['R'].values(), antdict['L'].values()]) == 0).all():
            missing.append(antenna)
    if missing:
        print("  missing antennas: {}".format(" ".join(missing)))
    for m in missing:
        del aips_rel_leak[m]
    freqs = np.array(sorted(allfreqs))
    freq_index = {f: i for i, f in enumerate(freqs)}
    ants = list(aips_rel_leak.keys())
    ant_index = {a: i for i, a in enumerate(ants)}
    leakage = np.zeros((1, len(allfreqs), len(ants), 2, 2), np.complex64)
    print("  {} antennas: {}".format(len(ants), " ".join(ants)))
    print("  freqs {} to {} MHz".format(*(freqs[[0, -1]] * 1e-6)))

    for antenna, antdict in aips_rel_leak.items():
        iant = ant_index[antenna]
        for icorr, corr in enumerate('RL'):
            corrdict = antdict[corr]
            ifreqs = [freq_index[f] for f in corrdict.keys()]
            leakage[0, ifreqs, iant, icorr, 1 - icorr] = np.array(corrdict.values())
    return leakage, ants, freqs

def apply_ref_ant(leak, refant, ant_index):
    iref = ant_index.get(refant)
    if iref is None:
        print("{}: unknown reference antenna '{}'".format(filename, refant))
    else:
        refleak = leak[:, :, iref, 0, 1].copy()
        leak[:, :, :, 0, 1] -= refleak[..., np.newaxis]
        leak[:, :, :, 1, 0] += np.conj(refleak)[..., np.newaxis]

def subtract_leakages(leak, antennas, leak0, ant0_index):
    diffleak = leak.copy()
    for iant, ant in enumerate(antennas):
        iant0 = ant0_index.get(ant)
        if iant0 is None:
            "{}: antenna {} not in {}, difference will be zero'ed".format(filename, ant, filename0)
            diffleak[:, :, iant, :, :] = 0
        else:
            diffleak[:, :, iant, :, :] -= leak0[:, :, iant0, :, :]
    return diffleak

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="""Makes plots of leakage solutions""",
                                     formatter_class=argparse.RawTextHelpFormatter)

    # parser.add_argument("-b", "--browser", action="store_true",
    #                     help="open a browser session, even if running under ssh.")
    # parser.add_argument("-n", "--no-browser", action="store_true",
    #                     help="do not open a browser session, even if running locally.")
    # parser.add_argument("--browser-command", type=str, metavar="CMD", default=DEFAULT_BROWSER,
    #                     help="browser command to run. Default is %(default)s (can also set RADIOPADRE_BROWSER).")
    #
    # parser.add_argument("-V", "--virtual-env", action="store_true",
    #                     help="run radiopadre using a virtualenv+local install, rather than via Docker (default).")
    # parser.add_argument("--venv-reinstall", action="store_true",
    #                     help="virtualenv: reinstall radiopadre virtual environment before running.")
    # parser.add_argument("--venv-no-casacore", action="store_true",
    #                     help="virtualenv: ignore casacore installation errors, if bootstrapping.")
    # parser.add_argument("--venv-no-js9", action="store_true",
    #                     help="virtualenv: Ignore JS9 installation errors, if bootstrapping.")
    #
    # parser.add_argument("-D", "--docker", action="store_true",
    #                     help="forces use of Docker for container mode. Default is to use Singularity if found, and fall\n"
    #                          "back to Docker if not.")
    #
    # parser.add_argument("-S", "--singularity", action="store_true",
    #                     help="forces use of Singularity for container mode. Fail if Singularity is not found.")
    #
    # parser.add_argument("-C", "--container-dev", "--docker-dev", action="store_true",
    #                     help="runs radiopadre via a Docker or Singularity container, but mounts the host-installed\n"
    #                          "version of radiopadre inside it. Intended for developers.")
    # parser.add_argument("--docker-image", type=str, metavar="IMAGE", default=DEFAULT_DOCKER_IMAGE,
    #                     help="Which Docker image to use. Default is %(default)s.")
    # parser.add_argument("--docker-detach", action="store_true",
    #                     help="detach from container and exit after setting everything up.")
    # parser.add_argument("--docker-debug", action="store_true",
    #                     help="run container in debug mode, with output to screen.")
    #
    # parser.add_argument("--auto-init", action="store_true",
    #                     help="automatically initialize radiopadre installation, if missing on remote.\n" +
    #                          "In virtualenv mode, also initialize virtual environment, if missing.")
    # parser.add_argument("--remote-path", type=str, metavar="PATH",
    #                     help="for virtualenv or dev-docker mode: directory in which remote radiopadre is installed.\n" +
    #                          "Default is to try ~/radiopadre first, and PATH second.\n")
    # parser.add_argument("-u", "--update", action="store_true",
    #                     help="in virtualenv mode: update remote radiopadre installation using git pull.\n"
    #                          "in docker mode: update docker container using docker pull.")
    #
    # parser.add_argument("--no-default", action="store_true",
    #                     help="if no notebooks are found in the specified directory, default is to create\n"
    #                          "a radiopadre-default.ipynb with some boilerplate. Use this option to disable.")
    # parser.add_argument("-a", "--auto-load", action="store_true",
    #                     help="automatically load first notebook found, if one is not given explicitly.")
    # parser.add_argument("-v", "--verbose", action="store_true",
    #                     help="Enable verbose output.")
    #
    # parser.add_argument("--docker-image", type=str, metavar="IMAGE", default=DEFAULT_DOCKER_IMAGE,
    #                     help="Which Docker image to use. Default is %(default)s.")


    parser.add_argument("-d", "--display", action="store_true", help="Display plots rather than saving them")

    parser.add_argument("-o", "--output-name", type=str, metavar="FILENAME", help="Output filename")

    parser.add_argument("-b", "--plot-bandpass", action="store_true", help="Display bandpass plots too")

    parser.add_argument("-r", "--ref-ant", metavar="ANTENNA", type=str, help="Impose a reference antenna on the leakages")

    parser.add_argument("--diff", action="store_true", help="Make difference plots if possible")

    parser.add_argument("--nrow", type=int, default=7, help="Plot rows")
    parser.add_argument("--ncol", type=int, default=4, help="Plot columns")
    parser.add_argument("--width", type=float, metavar="INCHES", default=4, help="Plot width")
    parser.add_argument("--height", type=float, metavar="INCHES", default=3, help="Plot height")
    parser.add_argument("--dpi", type=int, default=150, help="Plot DPI")
    parser.add_argument("--font-size", type=int, default=6, help="Font size")
    parser.add_argument("--min-freq", type=float, metavar="MHz", default=0, help="Start frequency")
    parser.add_argument("--max-freq", type=float, metavar="MHz", default=0, help="End frequency")
    parser.add_argument("--max-reim", type=float, metavar="VALUE", default=0.05, help="Sets re/im axis limits")

    parser.add_argument("files", nargs="+",
                         help="""One or more CubiCal solution databases or AIPS leakage files""")

    options = parser.parse_args()

    Daips0 = None

    for filename in options.files:
        # check file type
        line0 = open(filename).readline().strip()
        if line0.startswith("PD TABLE"):
            print("{} seems to be an AIPS PD table printout".format(filename))

            leak, antennas, freq = Daips = read_aips_leakages(filename)
            ant_index = {a: i for i, a in enumerate(antennas)}

            figtitle = filename
            output_name = options.output_name or filename + ".png"
            differential = False
            refant = None

            if options.ref_ant and options.ref_ant != "auto":
                refant = options.ref_ant
                apply_ref_ant(leak, options.ref_ant, ant_index)

            if options.diff:
                if Daips0 is None:
                    Daips0 = Daips
                    filename0 = filename
                else:
                    figtitle = "{} minus {}".format(filename, filename0)
                    output_name = options.output_name or filename + ".diff.png"
                    differential = True

                    leak0, antennas0, freq0 = Daips0
                    ant0_index = {a: i for i, a in enumerate(antennas0)}

                    if len(freq) != len(freq0) or (freq != freq0).any():
                        "{}: frequency axis mismatch, can't show difference to {}".format(filename, filename0)
                        continue

                    # look for best reference antenna
                    rms_diff = OrderedDict()
                    if options.ref_ant == "auto":
                        #print("Picking reference antenna for differencing")
                        for refant in set(antennas) & set(antennas0):
                            apply_ref_ant(leak, refant, ant_index)
                            apply_ref_ant(leak0, refant, ant0_index)
                            diffleak = subtract_leakages(leak, antennas, leak0, ant0_index)
                            rms_diff[refant] = diffleak[...,(0,1),(1,0)].std(axis=(1,-1)).mean(axis=1)
                            #print("  ref ant {}: mean rms {}".format(refant,rms_diff[refant]))
                        imin = np.argmin(np.array(rms_diff.values()))
                        refant = rms_diff.keys()[imin]
                        print("Auto-picking reference antenna {}".format(refant))
                        apply_ref_ant(leak, refant, ant_index)
                        apply_ref_ant(leak0, refant, ant0_index)

                    diffleak = subtract_leakages(leak, antennas, leak0, ant0_index)

                    Daips = diffleak, antennas, freq

            if refant:
                figtitle += " (re-referenced to antenna {})".format(refant)


            fig = plot_leakages_aips(Daips, reim=(-options.max_reim, options.max_reim),
                                       minfreq=options.min_freq*1e+6 or None,
                                       maxfreq=options.max_freq*1e+6 or None,
                                       figsize=(options.width*options.ncol, options.height*options.nrow),
                                       ncol=options.ncol,nrow=options.nrow,
                                       figtitle=figtitle, plot_bandpass=options.plot_bandpass, diff=differential)

            if options.display:
                print("Displaying plot")
#                fig.show()
            else:
                print("Saving plot to {}".format(output_name))
                fig.savefig(output_name, dpi=options.dpi, bbox_inches='tight')

    if options.display:
        show()